{"ast":null,"code":"import getEachDeep from './getEachDeep.js';\nimport getPathToString from './getPathToString.js';\nexport default function getMapKeysDeep(_) {\n  const eachDeep = getEachDeep(_);\n  const pathToString = getPathToString(_);\n  function mapKeysDeep(obj, iteratee) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    iteratee = _.iteratee(iteratee);\n    options.cloneDeep = options.cloneDeep || _.cloneDeep;\n    options.callbackAfterIterate = false;\n    const newPaths = [];\n    eachDeep(obj, function (value, key, parent, context) {\n      if (key === undefined) {\n        return;\n      }\n      const newKey = iteratee(value, key, parent, context) + '';\n      if (newKey === key) {\n        return;\n      }\n      const oldPath = context.path;\n      const oldPathStr = options.pathFormat === 'array' ? JSON.stringify(oldPath) : oldPath;\n      const newPath = options.pathFormat === 'array' ? [...(context.parent.path || []), ...(context.childrenPath || []), newKey] : pathToString([newKey], context.parent.path, context.childrenPath);\n      const newPathStr = options.pathFormat === 'array' ? JSON.stringify(newPath) : newPath;\n      if (!newPaths[context.depth - 1]) {\n        newPaths[context.depth - 1] = [];\n      }\n      newPaths[context.depth - 1].push({\n        oldPath,\n        oldPathStr,\n        newPath,\n        newPathStr\n      });\n    }, options);\n    const res = options.cloneDeep(obj);\n    let d = newPaths.length;\n    while (d--) {\n      if (!newPaths[d]) {\n        continue;\n      }\n      const overwritten = {};\n      newPaths[d].forEach(_ref => {\n        let {\n          oldPath,\n          oldPathStr,\n          newPath,\n          newPathStr\n        } = _ref;\n        let value;\n        if (Object.prototype.hasOwnProperty.call(overwritten, oldPathStr)) {\n          value = overwritten[oldPathStr];\n          delete overwritten[oldPathStr];\n        } else {\n          value = _.get(res, oldPath);\n          if (value === undefined && !_.has(res, oldPath)) {\n            return;\n          }\n          _.unset(res, oldPath);\n        }\n        if (_.has(res, newPath) && !Object.prototype.hasOwnProperty.call(overwritten, newPathStr)) {\n          overwritten[newPathStr] = _.get(res, newPath);\n        }\n        _.set(res, newPath, value);\n      });\n    }\n    return res;\n  }\n  return mapKeysDeep;\n}","map":{"version":3,"names":["getEachDeep","getPathToString","getMapKeysDeep","_","eachDeep","pathToString","mapKeysDeep","obj","iteratee","options","cloneDeep","callbackAfterIterate","newPaths","value","key","parent","context","undefined","newKey","oldPath","path","oldPathStr","pathFormat","JSON","stringify","newPath","childrenPath","newPathStr","depth","push","res","d","length","overwritten","forEach","Object","prototype","hasOwnProperty","call","get","has","unset","set"],"sources":["/Users/akwg7/Documents/react/RISE1/rise-clean/frontend/node_modules/deepdash/es/getMapKeysDeep.js"],"sourcesContent":["import getEachDeep from './getEachDeep.js';\nimport getPathToString from './getPathToString.js';\n\nexport default function getMapKeysDeep(_) {\n  const eachDeep = getEachDeep(_);\n  const pathToString = getPathToString(_);\n  function mapKeysDeep(obj, iteratee, options = {}) {\n    iteratee = _.iteratee(iteratee);\n    options.cloneDeep = options.cloneDeep || _.cloneDeep;\n    options.callbackAfterIterate = false;\n    const newPaths = [];\n\n    eachDeep(\n      obj,\n      function (value, key, parent, context) {\n        if (key === undefined) {\n          return;\n        }\n        const newKey = iteratee(value, key, parent, context) + '';\n        if (newKey === key) {\n          return;\n        }\n        const oldPath = context.path;\n        const oldPathStr =\n          options.pathFormat === 'array' ? JSON.stringify(oldPath) : oldPath;\n        const newPath =\n          options.pathFormat === 'array'\n            ? [\n                ...(context.parent.path || []),\n                ...(context.childrenPath || []),\n                newKey,\n              ]\n            : pathToString([newKey], context.parent.path, context.childrenPath);\n        const newPathStr =\n          options.pathFormat === 'array' ? JSON.stringify(newPath) : newPath;\n        if (!newPaths[context.depth - 1]) {\n          newPaths[context.depth - 1] = [];\n        }\n        newPaths[context.depth - 1].push({\n          oldPath,\n          oldPathStr,\n          newPath,\n          newPathStr,\n        });\n      },\n      options\n    );\n    const res = options.cloneDeep(obj);\n\n    let d = newPaths.length;\n    while (d--) {\n      if (!newPaths[d]) {\n        continue;\n      }\n      const overwritten = {};\n      newPaths[d].forEach(({ oldPath, oldPathStr, newPath, newPathStr }) => {\n        let value;\n        if (Object.prototype.hasOwnProperty.call(overwritten, oldPathStr)) {\n          value = overwritten[oldPathStr];\n          delete overwritten[oldPathStr];\n        } else {\n          value = _.get(res, oldPath);\n          if (value === undefined && !_.has(res, oldPath)) {\n            return;\n          }\n          _.unset(res, oldPath);\n        }\n        if (\n          _.has(res, newPath) &&\n          !Object.prototype.hasOwnProperty.call(overwritten, newPathStr)\n        ) {\n          overwritten[newPathStr] = _.get(res, newPath);\n        }\n        _.set(res, newPath, value);\n      });\n    }\n    return res;\n  }\n  return mapKeysDeep;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}