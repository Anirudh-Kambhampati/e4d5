{"ast":null,"code":"import getPathToString from './../getPathToString.js';\nimport isObject from './isObject.js';\nvar rxVarName = /^[a-zA-Z_$]+([\\w_$]*)$/;\nvar rxQuot = /\"/g;\nconst has = Object.prototype.hasOwnProperty;\nexport default function getIterate(_) {\n  const pathToString = getPathToString(_);\n  function iterate(item) {\n    const {\n      options,\n      obj,\n      callback\n    } = item;\n    options.pathFormatArray = options.pathFormat == 'array';\n    item.depth = 0;\n    let broken = false;\n    const breakIt = () => {\n      broken = true;\n      return false;\n    };\n    while (item) {\n      if (broken) break;\n      if (!item.inited) {\n        item.inited = true;\n        item.info = describeValue(item.value, options.ownPropertiesOnly);\n        if (options.checkCircular) {\n          item.circularParentIndex = -1;\n          item.circularParent = null;\n          item.isCircular = false;\n          if (item.info.isObject && !item.info.isEmpty) {\n            let parent = item.parent;\n            while (parent) {\n              if (parent.value === item.value) {\n                item.isCircular = true;\n                item.circularParent = parent;\n                item.circularParentIndex = item.depth - parent.depth - 1;\n                break;\n              }\n              parent = parent.parent;\n            }\n          }\n        }\n        item.children = [];\n        if (options.childrenPath) {\n          options.childrenPath.forEach((cp, i) => {\n            const children = _.get(item.value, cp);\n            const info = describeValue(children, options.ownPropertiesOnly);\n            if (!info.isEmpty) {\n              item.children.push([cp, options.strChildrenPath[i], children, info]);\n            }\n          });\n        }\n        item.isLeaf = item.isCircular || options.childrenPath !== undefined && !item.children.length || !item.info.isObject || item.info.isEmpty;\n        item.needCallback = (item.depth || options.includeRoot) && (!options.leavesOnly || item.isLeaf);\n        if (item.needCallback) {\n          const contextReader = new ContextReader(obj, options, breakIt);\n          contextReader.setItem(item, false);\n          try {\n            item.res = callback(item.value, item.key, item.parent && item.parent.value, contextReader);\n          } catch (err) {\n            if (err.message) {\n              err.message += '\\ncallback failed before deep iterate at:\\n' + pathToString(item.path);\n            }\n            throw err;\n          }\n        }\n        if (broken) {\n          break;\n        }\n        if (item.res !== false) {\n          if (!broken && !item.isCircular && item.info.isObject) {\n            if (options.childrenPath !== undefined && (item.depth || !options.rootIsChildren)) {\n              item.childrenItems = [];\n              if (item.children.length) {\n                item.children.forEach(_ref => {\n                  let [cp, scp, children, info] = _ref;\n                  item.childrenItems = [...item.childrenItems, ...(info.isArray ? getElements(item, children, options, cp, scp) : getOwnChildren(item, children, options, cp, scp))];\n                });\n              }\n            } else {\n              item.childrenItems = item.info.isArray ? getElements(item, item.value, options, [], '') : getOwnChildren(item, item.value, options, [], '');\n            }\n          }\n        }\n        item.currentChildIndex = -1;\n      }\n      if (item.childrenItems && item.currentChildIndex < item.childrenItems.length - 1) {\n        item.currentChildIndex++;\n        item.childrenItems[item.currentChildIndex].parentItem = item;\n        item = item.childrenItems[item.currentChildIndex];\n        continue;\n      }\n      if (item.needCallback && options.callbackAfterIterate) {\n        const contextReader = new ContextReader(obj, options, breakIt);\n        contextReader.setItem(item, true);\n        try {\n          callback(item.value, item.key, item.parent && item.parent.value, contextReader);\n        } catch (err) {\n          if (err.message) {\n            err.message += '\\ncallback failed after deep iterate at:\\n' + pathToString(item.path);\n          }\n          throw err;\n        }\n      }\n      item = item.parentItem;\n    }\n  }\n  return iterate;\n  function getElements(item, children, options, childrenPath, strChildrenPath) {\n    let strChildPathPrefix;\n    if (!options.pathFormatArray) {\n      strChildPathPrefix = item.strPath || '';\n      if (strChildrenPath && strChildPathPrefix && !strChildrenPath.startsWith('[')) {\n        strChildPathPrefix += '.';\n      }\n      strChildPathPrefix += strChildrenPath || '';\n    }\n    const res = [];\n    for (var i = 0; i < children.length; i++) {\n      const val = children[i];\n      if (val === undefined && !(i in children)) {\n        continue;\n      }\n      let strChildPath;\n      const pathFormatString = !options.pathFormatArray;\n      if (pathFormatString) {\n        strChildPath = `${strChildPathPrefix}[${i}]`;\n      }\n      res.push({\n        value: val,\n        key: i + '',\n        path: [...(item.path || []), ...childrenPath, i + ''],\n        strPath: strChildPath,\n        depth: item.depth + 1,\n        parent: {\n          value: item.value,\n          key: item.key,\n          path: pathFormatString ? item.strPath : item.path,\n          parent: item.parent,\n          depth: item.depth,\n          info: item.info\n        },\n        childrenPath: childrenPath.length && childrenPath || undefined,\n        strChildrenPath: strChildrenPath || undefined\n      });\n    }\n    return res;\n  }\n  function getOwnChildren(item, children, options, childrenPath, strChildrenPath) {\n    let strChildPathPrefix;\n    if (!options.pathFormatArray) {\n      strChildPathPrefix = item.strPath || '';\n      if (strChildrenPath && strChildPathPrefix && !strChildrenPath.startsWith('[')) {\n        strChildPathPrefix += '.';\n      }\n      strChildPathPrefix += strChildrenPath || '';\n    }\n    const res = [];\n    const pathFormatString = !options.pathFormatArray;\n    for (var childKey in children) {\n      if (options.ownPropertiesOnly && !has.call(children, childKey)) {\n        continue;\n      }\n      let strChildPath;\n      if (pathFormatString) {\n        if (rxVarName.test(childKey)) {\n          if (strChildPathPrefix) {\n            strChildPath = `${strChildPathPrefix}.${childKey}`;\n          } else {\n            strChildPath = `${childKey}`;\n          }\n        } else {\n          strChildPath = `${strChildPathPrefix}[\"${childKey.replace(rxQuot, '\\\\\"')}\"]`;\n        }\n      }\n      res.push({\n        value: children[childKey],\n        key: childKey,\n        path: [...(item.path || []), ...childrenPath, childKey],\n        strPath: strChildPath,\n        depth: item.depth + 1,\n        parent: {\n          value: item.value,\n          key: item.key,\n          path: pathFormatString ? item.strPath : item.path,\n          parent: item.parent,\n          depth: item.depth,\n          info: item.info\n        },\n        childrenPath: childrenPath.length && childrenPath || undefined,\n        strChildrenPath: strChildrenPath || undefined\n      });\n    }\n    return res;\n  }\n}\nclass ContextReader {\n  constructor(obj, options, breakIt) {\n    this.obj = obj;\n    this._options = options;\n    this['break'] = breakIt;\n  }\n  setItem(item, afterIterate) {\n    this._item = item;\n    this.afterIterate = afterIterate;\n  }\n  get path() {\n    return this._options.pathFormatArray ? this._item.path : this._item.strPath;\n  }\n  get parent() {\n    return this._item.parent;\n  }\n  get parents() {\n    if (!this._item._parents) {\n      this._item._parents = [];\n      let curParent = this._item.parent;\n      while (curParent) {\n        this._item._parents[curParent.depth] = curParent;\n        curParent = curParent.parent;\n      }\n    }\n    return this._item._parents;\n  }\n  get depth() {\n    return this._item.depth;\n  }\n  get isLeaf() {\n    return this._item.isLeaf;\n  }\n  get isCircular() {\n    return this._item.isCircular;\n  }\n  get circularParentIndex() {\n    return this._item.circularParentIndex;\n  }\n  get circularParent() {\n    return this._item.circularParent;\n  }\n  get childrenPath() {\n    return this._options.childrenPath !== undefined && (this._options.pathFormatArray ? this._item.childrenPath : this._item.strChildrenPath) || undefined;\n  }\n  get info() {\n    return this._item.info;\n  }\n}\nfunction isObjectEmpty(value, ownPropertiesOnly) {\n  for (var key in value) {\n    if (!ownPropertiesOnly || has.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction describeValue(value, ownPropertiesOnly) {\n  const res = {\n    isObject: isObject(value)\n  };\n  res.isArray = res.isObject && Array.isArray(value);\n  res.isEmpty = res.isArray ? !value.length : res.isObject ? isObjectEmpty(value, ownPropertiesOnly) : true;\n  return res;\n}","map":{"version":3,"names":["getPathToString","isObject","rxVarName","rxQuot","has","Object","prototype","hasOwnProperty","getIterate","_","pathToString","iterate","item","options","obj","callback","pathFormatArray","pathFormat","depth","broken","breakIt","inited","info","describeValue","value","ownPropertiesOnly","checkCircular","circularParentIndex","circularParent","isCircular","isEmpty","parent","children","childrenPath","forEach","cp","i","get","push","strChildrenPath","isLeaf","undefined","length","needCallback","includeRoot","leavesOnly","contextReader","ContextReader","setItem","res","key","err","message","path","rootIsChildren","childrenItems","scp","isArray","getElements","getOwnChildren","currentChildIndex","parentItem","callbackAfterIterate","strChildPathPrefix","strPath","startsWith","val","strChildPath","pathFormatString","childKey","call","test","replace","constructor","_options","afterIterate","_item","parents","_parents","curParent","isObjectEmpty","Array"],"sources":["/Users/akwg7/Documents/react/RISE1/rise-clean/frontend/node_modules/deepdash/es/private/getIterate.js"],"sourcesContent":["import getPathToString from './../getPathToString.js';\nimport isObject from './isObject.js';\nvar rxVarName = /^[a-zA-Z_$]+([\\w_$]*)$/;\nvar rxQuot = /\"/g;\nconst has = Object.prototype.hasOwnProperty;\n\nexport default function getIterate(_) {\n  const pathToString = getPathToString(_);\n\n  function iterate(item) {\n    const { options, obj, callback } = item;\n    options.pathFormatArray = options.pathFormat == 'array';\n    item.depth = 0;\n\n    let broken = false;\n    const breakIt = () => {\n      broken = true;\n      return false;\n    };\n\n    while (item) {\n      if (broken) break;\n      if (!item.inited) {\n        item.inited = true;\n        item.info = describeValue(item.value, options.ownPropertiesOnly);\n\n        if (options.checkCircular) {\n          item.circularParentIndex = -1;\n          item.circularParent = null;\n          item.isCircular = false;\n          if (item.info.isObject && !item.info.isEmpty) {\n            let parent = item.parent;\n            while (parent) {\n              if (parent.value === item.value) {\n                item.isCircular = true;\n                item.circularParent = parent;\n                item.circularParentIndex = item.depth - parent.depth - 1;\n                break;\n              }\n              parent = parent.parent;\n            }\n          }\n        }\n\n        item.children = [];\n        if (options.childrenPath) {\n          options.childrenPath.forEach((cp, i) => {\n            const children = _.get(item.value, cp);\n            const info = describeValue(children, options.ownPropertiesOnly);\n            if (!info.isEmpty) {\n              item.children.push([\n                cp,\n                options.strChildrenPath[i],\n                children,\n                info,\n              ]);\n            }\n          });\n        }\n\n        item.isLeaf =\n          item.isCircular ||\n          (options.childrenPath !== undefined && !item.children.length) ||\n          !item.info.isObject ||\n          item.info.isEmpty;\n\n        item.needCallback =\n          (item.depth || options.includeRoot) &&\n          (!options.leavesOnly || item.isLeaf);\n\n        if (item.needCallback) {\n          const contextReader = new ContextReader(obj, options, breakIt);\n          contextReader.setItem(item, false);\n          try {\n            item.res = callback(\n              item.value,\n              item.key,\n              item.parent && item.parent.value,\n              contextReader\n            );\n          } catch (err) {\n            if (err.message) {\n              err.message +=\n                '\\ncallback failed before deep iterate at:\\n' +\n                pathToString(item.path);\n            }\n\n            throw err;\n          }\n        }\n\n        if (broken) {\n          break;\n        }\n\n        if (item.res !== false) {\n          if (!broken && !item.isCircular && item.info.isObject) {\n            if (\n              options.childrenPath !== undefined &&\n              (item.depth || !options.rootIsChildren)\n            ) {\n              item.childrenItems = [];\n              if (item.children.length) {\n                item.children.forEach(([cp, scp, children, info]) => {\n                  item.childrenItems = [\n                    ...item.childrenItems,\n                    ...(info.isArray\n                      ? getElements(item, children, options, cp, scp)\n                      : getOwnChildren(item, children, options, cp, scp)),\n                  ];\n                });\n              }\n            } else {\n              item.childrenItems = item.info.isArray\n                ? getElements(item, item.value, options, [], '')\n                : getOwnChildren(item, item.value, options, [], '');\n            }\n          }\n        }\n\n        item.currentChildIndex = -1;\n      }\n      if (\n        item.childrenItems &&\n        item.currentChildIndex < item.childrenItems.length - 1\n      ) {\n        item.currentChildIndex++;\n        item.childrenItems[item.currentChildIndex].parentItem = item;\n        item = item.childrenItems[item.currentChildIndex];\n        continue;\n      }\n\n      if (item.needCallback && options.callbackAfterIterate) {\n        const contextReader = new ContextReader(obj, options, breakIt);\n        contextReader.setItem(item, true);\n\n        try {\n          callback(\n            item.value,\n            item.key,\n            item.parent && item.parent.value,\n            contextReader\n          );\n        } catch (err) {\n          if (err.message) {\n            err.message +=\n              '\\ncallback failed after deep iterate at:\\n' +\n              pathToString(item.path);\n          }\n\n          throw err;\n        }\n      }\n      item = item.parentItem;\n    }\n  }\n\n  return iterate;\n\n  function getElements(item, children, options, childrenPath, strChildrenPath) {\n    let strChildPathPrefix;\n    if (!options.pathFormatArray) {\n      strChildPathPrefix = item.strPath || '';\n\n      if (\n        strChildrenPath &&\n        strChildPathPrefix &&\n        !strChildrenPath.startsWith('[')\n      ) {\n        strChildPathPrefix += '.';\n      }\n      strChildPathPrefix += strChildrenPath || '';\n    }\n    const res = [];\n    for (var i = 0; i < children.length; i++) {\n      const val = children[i];\n      if (val === undefined && !(i in children)) {\n        continue;\n      }\n      let strChildPath;\n      const pathFormatString = !options.pathFormatArray;\n      if (pathFormatString) {\n        strChildPath = `${strChildPathPrefix}[${i}]`;\n      }\n      res.push({\n        value: val,\n        key: i + '',\n        path: [...(item.path || []), ...childrenPath, i + ''],\n        strPath: strChildPath,\n        depth: item.depth + 1,\n        parent: {\n          value: item.value,\n          key: item.key,\n          path: pathFormatString ? item.strPath : item.path,\n          parent: item.parent,\n          depth: item.depth,\n          info: item.info,\n        },\n        childrenPath: (childrenPath.length && childrenPath) || undefined,\n        strChildrenPath: strChildrenPath || undefined,\n      });\n    }\n    return res;\n  }\n\n  function getOwnChildren(\n    item,\n    children,\n    options,\n    childrenPath,\n    strChildrenPath\n  ) {\n    let strChildPathPrefix;\n    if (!options.pathFormatArray) {\n      strChildPathPrefix = item.strPath || '';\n\n      if (\n        strChildrenPath &&\n        strChildPathPrefix &&\n        !strChildrenPath.startsWith('[')\n      ) {\n        strChildPathPrefix += '.';\n      }\n      strChildPathPrefix += strChildrenPath || '';\n    }\n    const res = [];\n    const pathFormatString = !options.pathFormatArray;\n    for (var childKey in children) {\n      if (options.ownPropertiesOnly && !has.call(children, childKey)) {\n        continue;\n      }\n\n      let strChildPath;\n      if (pathFormatString) {\n        if (rxVarName.test(childKey)) {\n          if (strChildPathPrefix) {\n            strChildPath = `${strChildPathPrefix}.${childKey}`;\n          } else {\n            strChildPath = `${childKey}`;\n          }\n        } else {\n          strChildPath = `${strChildPathPrefix}[\"${childKey.replace(\n            rxQuot,\n            '\\\\\"'\n          )}\"]`;\n        }\n      }\n\n      res.push({\n        value: children[childKey],\n        key: childKey,\n        path: [...(item.path || []), ...childrenPath, childKey],\n        strPath: strChildPath,\n        depth: item.depth + 1,\n        parent: {\n          value: item.value,\n          key: item.key,\n          path: pathFormatString ? item.strPath : item.path,\n          parent: item.parent,\n          depth: item.depth,\n          info: item.info,\n        },\n        childrenPath: (childrenPath.length && childrenPath) || undefined,\n        strChildrenPath: strChildrenPath || undefined,\n      });\n    }\n\n    return res;\n  }\n}\n\nclass ContextReader {\n  constructor(obj, options, breakIt) {\n    this.obj = obj;\n    this._options = options;\n    this['break'] = breakIt;\n  }\n  setItem(item, afterIterate) {\n    this._item = item;\n    this.afterIterate = afterIterate;\n  }\n  get path() {\n    return this._options.pathFormatArray ? this._item.path : this._item.strPath;\n  }\n\n  get parent() {\n    return this._item.parent;\n  }\n\n  get parents() {\n    if (!this._item._parents) {\n      this._item._parents = [];\n      let curParent = this._item.parent;\n      while (curParent) {\n        this._item._parents[curParent.depth] = curParent;\n        curParent = curParent.parent;\n      }\n    }\n    return this._item._parents;\n  }\n  get depth() {\n    return this._item.depth;\n  }\n\n  get isLeaf() {\n    return this._item.isLeaf;\n  }\n\n  get isCircular() {\n    return this._item.isCircular;\n  }\n\n  get circularParentIndex() {\n    return this._item.circularParentIndex;\n  }\n\n  get circularParent() {\n    return this._item.circularParent;\n  }\n\n  get childrenPath() {\n    return (\n      (this._options.childrenPath !== undefined &&\n        (this._options.pathFormatArray\n          ? this._item.childrenPath\n          : this._item.strChildrenPath)) ||\n      undefined\n    );\n  }\n\n  get info() {\n    return this._item.info;\n  }\n}\n\nfunction isObjectEmpty(value, ownPropertiesOnly) {\n  for (var key in value) {\n    if (!ownPropertiesOnly || has.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction describeValue(value, ownPropertiesOnly) {\n  const res = { isObject: isObject(value) };\n  res.isArray = res.isObject && Array.isArray(value);\n  res.isEmpty = res.isArray\n    ? !value.length\n    : res.isObject\n    ? isObjectEmpty(value, ownPropertiesOnly)\n    : true;\n\n  return res;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}